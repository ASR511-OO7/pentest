#!/bin/bash

#####################################
# Variables section
#####################################

GIT_REPO=""
GREP_PATTERN=".*"

# Script directory
SCRIPT_DIR=$(dirname $(readlink -f $0))

#####################################
# Help
#####################################
function help(){
    echo "Usage: $0 [-g git_repo] [-p pattern]"
    echo "       [-g git_repo]    :GIT repository directory"
    echo "       [-p pattern]     :pattern used to grep GIT tags - example \"^7\.[0-9]+$\""
    echo
    echo "Example of command:"
    echo "./versionchecker.sh -g ~/Documents/repo/drupal/ -p \"^[78]\.[0-9.]+$\""
    exit 1
}

if [ $# -ne 0 ] && [ $# -ne 2 ] && [ $# -ne 4 ];then
    help
fi

#####################################
# Getting options
#####################################
while getopts "g:p:" OPT;do
    case "${OPT}" in
         g)
            GIT_REPO="${OPTARG}"
            if [ ! -d "${GIT_REPO}" ];then
                echo "[!] GIT repository ${GIT_REPO} not found"
                help
            fi
            echo "[*] GIT repository: ${GIT_REPO}"
            ;;
        p)
            GREP_PATTERN="${OPTARG}"
            if [ "X" == "X""${GREP_PATTERN}" ];then
                echo "[!] Grep pattern is empty"
                help
            fi
            echo "[*] Grep pattern: ${GREP_PATTERN}"
            ;;
        :)
            echo "[!] Invalid option ${OPT}"
            help
            ;;
    esac
done

#####################################
# Function versions comparison
#####################################
function version_gt(){
    test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1";
}

#####################################
# Function hashing the repository files
#####################################
function hash_files(){
    
    # Move to GIT repository
    cd "${GIT_REPO}"

    # Check if the hashes file is existing
    if [ -f "${SCRIPT_DIR}/work/hashes.txt" ];then
        echo -n "[*] ${SCRIPT_DIR}/work/hashes.txt found. Are you sure you want to overwrite and compute hashes [Y/n]: "
        read -e YESNO
    fi

    # Ok we can compute hashes from the GIT repository for every tags matching the specified pattern
    if [ "${YESNO,,}""X" != "nX" ]; then

        # Removing any lock file
        rm -f ".git/index.lock" &>/dev/null

        # Deleting existing hashes.txt file
        rm -f "${SCRIPT_DIR}/work/hashes.txt" &>/dev/null

        # Looping on each GIT tags
        for tag in $(git tag | egrep "${GREP_PATTERN}" | sort -V);do

            echo "[*] -----------------------"
            echo "[*] Looking for tag: ${tag}"

            # Forcing checkout
            git checkout -f "${tag}" &>/dev/null

            # Cleaning GIT tag (status should never change) - Removing untracked files
            git clean -d -fx . &>/dev/null

            # Cleaning GIT tag (status should never change) - Resetting to HEAD
            git reset --hard HEAD &>/dev/null

            # Looping on each input file and finding them in the repository
            for file in $(ls -1 ${SCRIPT_DIR}/input);do

                file_to_hash=$(find ${GIT_REPO} -type f -name "${file}")
                echo "[*] Looking in repo for file: ${file}"

                # We are checking if the filename is consistent
                if [ -f "${file_to_hash}" ];then
                    echo "[*] Found : ${file_to_hash}"
                    echo "${tag}:$(basename ${file_to_hash}):$(md5sum ${file_to_hash} | cut -d' ' -f1)" | tee -a "${SCRIPT_DIR}/work/hashes.txt"
                else
                    echo "[!] Finding ${file} in repository ${GIT_REPO} failed"
                fi
            done
        done
    fi
}

#####################################
# Function get version
#####################################
function get_version(){
    
    # Have some hashes already been computed ? 
    if [ ! -f "${SCRIPT_DIR}/work/hashes.txt" ];then
        echo "[!] ${SCRIPT_DIR}/work/hashes.txt is missing"
        echo "[!] You'd better specify a GIT repository in order to compute hashes first"
        exit 1
    fi

    # Looping on each input file to hash it and find its matching versions
    for file_to_check in $(ls -1 "${SCRIPT_DIR}/input");do

        file_to_check="${SCRIPT_DIR}/input/${file_to_check}"

        # Check that the file is physically present in input directory
        if [ ! -f "${file_to_check}" ];then
            echo "[*] File ${file_to_check} can not be found."
        else

            # We are computing hash (of file previously downloaded from the target server)
            # We should take care about the encoding
            file_to_check_hash=$(md5sum "${file_to_check}" | cut -d' ' -f1)

            echo "[*] -----------------------"
            echo "[*] Checking filename ${file_to_check}: ${file_to_check_hash}"
            grep_hash=$(grep "${file_to_check_hash}" "${SCRIPT_DIR}/work/hashes.txt")

            # Looking if hash has been found in the computed hashes file hashes.txt
            if [ "X" != "X""${grep_hash}" ];then
                min_version_tmp=$(echo "${grep_hash}" | sort -V | head -1 | cut -d":" -f1)
                max_version_tmp=$(echo "${grep_hash}" | sort -Vr | head -1 | cut -d":" -f1)

                # We are looking for the highest value in low ones fork
                if version_gt ${min_version_tmp} ${min_version};then
                    min_version=${min_version_tmp}
                fi

                # We are looking for the lowest value in high ones fork
                if [ $(echo ${max_version}"=="0 | bc -l) -eq 1 ];then
                    max_version=${max_version_tmp}
                elif version_gt ${max_version} ${max_version_tmp};then
                    max_version=${max_version_tmp}
                fi

                echo "${grep_hash}"

            else
                echo "[!] Hash can not be found in computed hashes"
                echo "[!] Be sure the $(basename ${file_to_check}) file is present in the GIT tags you have selected"
                echo "[!] Be sure encoding is the same between files compared (try dos2unix ${SCRIPT_DIR}/input/*)"
                echo "[!] Analysis is non consistent...14|\/|32!!!."
                exit 1
            fi
        fi
    done
}

#####################################
# Main
#####################################

# Creating the missing directories
if [ ! -d ${SCRIPT_DIR}/work ];then
    mkdir ${SCRIPT_DIR}/work
fi

if [ ! -d ${SCRIPT_DIR}/input ];then
    mkdir ${SCRIPT_DIR}/input
fi

# Some checks
# Is the input directory empty ?
# Todo: ask for a specific CMS and automatically download relevant files from target and do the comparison
if [ "$(ls ${SCRIPT_DIR}/input)""X" == "X" ];then
    echo "[!] Input directory ${SCRIPT_DIR}/input is empty. Nothing to compare."
    exit 1
fi

# Kiff section
echo "        ___           ___           ___           ___                       ___           ___       "
echo "       /\\__\\         /\\  \\         /\\  \\         /\\  \\          ___        /\\  \\         /\\__\\      "
echo "      /:/  /        /::\\  \\       /::\\  \\       /::\\  \\        /\\  \\      /::\\  \\       /::|  |     "
echo "     /:/  /        /:/\\:\\  \\     /:/\\:\\  \\     /:/\\ \\  \\       \\:\\  \\    /:/\\:\\  \\     /:|:|  |     "
echo "    /:/__/  ___   /::\\~\\:\\  \\   /::\\~\\:\\  \\   _\\:\\~\\ \\  \\      /::\\__\\  /:/  \\:\\  \\   /:/|:|  |__   "
echo "    |:|  | /\\__\\ /:/\\:\\ \\:\\__\\ /:/\\:\\ \\:\\__\\ /\\ \\:\\ \\ \\__\\  __/:/\\/__/ /:/__/ \\:\\__\\ /:/ |:| /\\__\\  "
echo "    |:|  |/:/  / \\:\\~\\:\\ \\/__/ \\/_|::\\/:/  / \\:\\ \\:\\ \\/__/ /\\/:/  /    \\:\\  \\ /:/  / \\/__|:|/:/  /  "
echo "    |:|__/:/  /   \\:\\ \\:\\__\\      |:|::/  /   \\:\\ \\:\\__\\   \\::/__/      \\:\\  /:/  /      |:/:/  /   "
echo "     \\::::/__/     \\:\\ \\/__/      |:|\\/__/     \\:\\/:/  /    \\:\\__\\       \\:\\/:/  /       |::/  /    "
echo "      ~~~~          \\:\\__\\        |:|  |        \\::/  /      \\/__/        \\::/  /        /:/  /     "
echo "                     \\/__/         \\|__|         \\/__/                     \\/__/         \\/__/      "
echo "        ___           ___           ___           ___           ___           ___           ___     "
echo "       /\\  \\         /\\__\\         /\\  \\         /\\  \\         /\\__\\         /\\  \\         /\\  \\    "
echo "      /::\\  \\       /:/  /        /::\\  \\       /::\\  \\       /:/  /        /::\\  \\       /::\\  \\   "
echo "     /:/\\:\\  \\     /:/__/        /:/\\:\\  \\     /:/\\:\\  \\     /:/__/        /:/\\:\\  \\     /:/\\:\\  \\  "
echo "    /:/  \\:\\  \\   /::\\  \\ ___   /::\\~\\:\\  \\   /:/  \\:\\  \\   /::\\__\\____   /::\\~\\:\\  \\   /::\\~\\:\\  \\ "
echo "   /:/__/ \\:\\__\\ /:/\\:\\  /\\__\\ /:/\\:\\ \\:\\__\\ /:/__/ \\:\\__\\ /:/\\:::::\\__\\ /:/\\:\\ \\:\\__\\ /:/\\:\\ \\:\\__\\"
echo "   \\:\\  \\  \\/__/ \\/__\\:\\/:/  / \\:\\~\\:\\ \\/__/ \\:\\  \\  \\/__/ \\/_|:|~~|~    \\:\\~\\:\\ \\/__/ \\/_|::\\/:/  /"
echo "    \\:\\  \\            \\::/  /   \\:\\ \\:\\__\\    \\:\\  \\          |:|  |      \\:\\ \\:\\__\\      |:|::/  / "
echo "     \\:\\  \\           /:/  /     \\:\\ \\/__/     \\:\\  \\         |:|  |       \\:\\ \\/__/      |:|\\/__/  "
echo "      \\:\\__\\         /:/  /       \\:\\__\\        \\:\\__\\        |:|  |        \\:\\__\\        |:|  |    "
echo "       \\/__/         \\/__/         \\/__/         \\/__/         \\|__|         \\/__/         \\|__|    "
echo 
echo
echo "[*] Hint: for choosing relevant files to compare from a GIT repository:"
echo "[*] git log --branches --pretty=format: --name-only | sort | uniq -c | sort -rg | head -20"
echo

# Let's rumble!
if [ "X" != "X""${GIT_REPO}" ];then
    hash_files
fi

# min/max versions
min_version=0
max_version=0

get_version

echo "[*] Thanks to strong and costly mathematical and statistical calculation:"
echo "[*] min version: ${min_version}"
echo "[*] max version: ${max_version}"
